package leaf

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"
	"errors"
	"io"
	"strings"
	"testing"
	"time"

	ecies "github.com/ecies/go/v2"
	"github.com/stretchr/testify/require"
)

// Generate shared secret using ECDH
func generateSharedSecret(privateKey *ecdsa.PrivateKey, publicKey *ecdsa.PublicKey) ([]byte, error) {
	x, _ := publicKey.Curve.ScalarMult(publicKey.X, publicKey.Y, privateKey.D.Bytes())
	ecies.GenerateKey()
	return x.Bytes(), nil
}

// Derive AES key from shared secret
func deriveAESKey(sharedSecret []byte) []byte {
	hash := sha256.New()
	hash.Write(sharedSecret)
	return hash.Sum(nil)
}

// Encrypt function using ECIES, generated by GPT
func encrypt(publicKey *ecdsa.PublicKey, plaintext []byte) ([]byte, error) {
	// Generate ephemeral key pair for ECDH
	ephemeralPrivateKey, err := ecdsa.GenerateKey(publicKey.Curve, rand.Reader)
	if err != nil {
		return nil, err
	}

	// Generate shared secret
	sharedSecret, err := generateSharedSecret(ephemeralPrivateKey, publicKey)
	if err != nil {
		return nil, err
	}

	// Derive AES key
	key := deriveAESKey(sharedSecret)

	// Encrypt using AES-GCM
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	nonce := make([]byte, aesGCM.NonceSize())
	if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, err
	}

	ciphertext := aesGCM.Seal(nonce, nonce, plaintext, nil)

	// Marshal ephemeral public key
	ephemeralPublicKey := elliptic.Marshal(ephemeralPrivateKey.Curve, ephemeralPrivateKey.PublicKey.X, ephemeralPrivateKey.PublicKey.Y)

	// Return ephemeral public key and ciphertext
	return append(ephemeralPublicKey, ciphertext...), nil
}

// Decrypt function using ECIES, generated by GPT
func decrypt(privateKey *ecdsa.PrivateKey, ciphertext []byte) ([]byte, error) {
	curve := privateKey.Curve
	byteLen := (curve.Params().BitSize + 7) / 8

	// Extract ephemeral public key
	ephemeralPublicKeyBytes := ciphertext[:1+2*byteLen]
	ephemeralPublicKeyX, ephemeralPublicKeyY := elliptic.Unmarshal(curve, ephemeralPublicKeyBytes)
	if ephemeralPublicKeyX == nil {
		return nil, errors.New("failed to unmarshal ephemeral public key")
	}
	ephemeralPublicKey := &ecdsa.PublicKey{Curve: curve, X: ephemeralPublicKeyX, Y: ephemeralPublicKeyY}

	// Extract actual ciphertext
	ciphertext = ciphertext[1+2*byteLen:]

	// Generate shared secret
	sharedSecret, err := generateSharedSecret(privateKey, ephemeralPublicKey)
	if err != nil {
		return nil, err
	}

	// Derive AES key
	key := deriveAESKey(sharedSecret)

	// Decrypt using AES-GCM
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	nonceSize := aesGCM.NonceSize()
	nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]
	plaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		return nil, err
	}

	return plaintext, nil
}

// Same as TestEncryptDecryptECIES but using raw ECDSA to show more concretely of how the implementation actually works
func TestEncryptDecryptRaw(t *testing.T) {
	req := require.New(t)

	// Generate a 256-bit elliptic curve private key
	privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		req.NoError(err, "Failed to generate private key")
	}
	payload := []byte("hello world")
	ciphertext, err := encrypt(&privateKey.PublicKey, payload)
	req.NoError(err, "Failed to encrypt payload")

	now := time.Now()
	decrypted, err := decrypt(privateKey, ciphertext)
	t.Logf("Time taken: %v", time.Since(now))
	req.NoError(err, "Failed to decrypt payload")
	req.Equal(payload, decrypted, "Decrypted payload does not match original payload")
}

func testEncryptDecryptECIES(t *testing.T, payload string) {
	req := require.New(t)

	k, err := ecies.GenerateKey()
	req.NoError(err)

	ciphertext, err := ecies.Encrypt(k.PublicKey, []byte(payload))
	req.NoError(err)

	now := time.Now()
	plaintext, err := ecies.Decrypt(k, ciphertext)
	t.Logf("Time taken: %v", time.Since(now))
	req.NoError(err)

	req.Equal(payload, string(plaintext))
}

func TestEncryptDecryptECIES_SmallPayload(t *testing.T) {
	testEncryptDecryptECIES(t, "hello world")
}

func TestEncryptDecryptECIES_LargePayload(t *testing.T) {
	// generate a payload of 1 KiB by repeating "helloworld" 100 times
	payload := strings.Repeat("helloworld", 100)
	require.Len(t, []byte(payload), 1000)
	testEncryptDecryptECIES(t, payload)
}

func TestEncryptDecryptECIES_VeryLargePayload(t *testing.T) {
	// generate a payload of 100 MiB by repeating "helloworld" 10,000,000 times
	payload := strings.Repeat("helloworld", 10_000_000)
	require.Len(t, []byte(payload), 100_000_000)
	testEncryptDecryptECIES(t, payload)
}

func BenchmarkDecryptECIES_VeryLargePayload(b *testing.B) {
	payload := strings.Repeat("helloworld", 10_000_000)
	require.Len(b, []byte(payload), 100_000_000)

	k, err := ecies.GenerateKey()
	require.NoError(b, err)

	ciphertext, err := ecies.Encrypt(k.PublicKey, []byte(payload))
	require.NoError(b, err)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := ecies.Decrypt(k, ciphertext)
		require.NoError(b, err)
	}
}
